<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Components</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">Components</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>FacetState</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>facet/facet.service.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#expanded">expanded</a>
                                </li>
                                <li>
                                        <a href="#hidden">hidden</a>
                                </li>
                                <li>
                                        <a href="#name">name</a>
                                </li>
                                <li>
                                        <a href="#position">position</a>
                                </li>
                                <li>
                                        <a href="#view">view</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="expanded"></a>
                                        <span class="name"><b>expanded</b><a href="#expanded"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>expanded:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="hidden"></a>
                                        <span class="name"><b>hidden</b><a href="#hidden"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>hidden:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="name"></a>
                                        <span class="name"><b>name</b><a href="#name"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>name:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="position"></a>
                                        <span class="name"><b>position</b><a href="#position"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>position:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="view"></a>
                                        <span class="name"><b>view</b><a href="#view"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>view:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {Injectable, Inject, Optional, InjectionToken} from &quot;@angular/core&quot;;
import {UserSettingsWebService, UserSettings, Suggestion,
    Results, Aggregation, AggregationItem, TreeAggregation, TreeAggregationNode,
    AuditEvents} from &quot;@sinequa/core/web-services&quot;;
import {IntlService} from &quot;@sinequa/core/intl&quot;;
import {Query, AppService, FormatService, ValueItem, Expr, ExprOperator, ExprParser} from &quot;@sinequa/core/app-utils&quot;;
import {Utils} from &quot;@sinequa/core/base&quot;;
import {Subject, Observable} from &quot;rxjs&quot;;
import {map} from &quot;rxjs/operators&quot;;
import {SearchService} from &quot;@sinequa/components/search&quot;;
import {SuggestService} from &quot;@sinequa/components/autocomplete&quot;;

// Facet interface (from models/UserSettings)
export interface FacetState {
    name: string;
    position: number; // eg 0 &#x3D; left, 1 &#x3D; right
    expanded: boolean;
    hidden: boolean;
    view: string;
}

/**
 * Options for the [[FacetService.AddFilter]] and [[FacetService.AddFilterSearch]] methods
 *
 * and: If multiple items are filtered, determines whether they are filtered as AND or OR
 * not: Whether this is an exlusion of the filtered item
 * replaceCurrent: if true, the current filter is replaced
 */
export interface AddFilterOptions {
    and?: boolean;
    not?: boolean;
    replaceCurrent?: boolean;
}

// Audit Events (from models/Audit)
export const enum FacetEventType {
    Loaded &#x3D; &quot;Facet_Loaded&quot;,
    Add &#x3D; &quot;Facet_Added&quot;,
    Remove &#x3D; &quot;Facet_Removed&quot;,

    Patched &#x3D; &quot;Facet_Patched&quot;,
    ClearFilters &#x3D; &quot;Facet_ClearFilters&quot;,
    AddFilter &#x3D; &quot;Facet_AddFilter&quot;,
    RemoveFilter &#x3D; &quot;Facet_RemoveFilter&quot;,
    Open &#x3D; &quot;Facet_TreeOpen&quot;
}

// Types of events triggering a change event
export const FACET_CHANGE_EVENTS &#x3D; [
    FacetEventType.Loaded,
    FacetEventType.Add,
    FacetEventType.Remove
];


// CRUD Events
export interface FacetChangeEvent {
    type: FacetEventType;
    facet?: FacetState;
}

export const ALL_FACETS &#x3D; new InjectionToken&lt;any[]&gt;(&#x27;ALL_FACETS&#x27;);
export const DEFAULT_FACETS &#x3D; new InjectionToken&lt;FacetState[]&gt;(&#x27;DEFAULT_FACETS&#x27;);

@Injectable({
    providedIn: &#x27;root&#x27;,
})
export class FacetService {

    private readonly _events &#x3D; new Subject&lt;FacetChangeEvent&gt;();
    private readonly _changes &#x3D; new Subject&lt;FacetChangeEvent&gt;();

    constructor(
        private userSettingsService: UserSettingsWebService,
        private searchService: SearchService,
        private suggestService: SuggestService,
        private appService: AppService,
        private intlService: IntlService,
        private formatService: FormatService,
        @Optional() @Inject(ALL_FACETS) private allFacets: any[],
        @Optional() @Inject(DEFAULT_FACETS) private defaultFacets: FacetState[]){

        // Listen to the user settings
        this.userSettingsService.events.subscribe(event &#x3D;&gt; {
            // E.g. new login occurs
            // &#x3D;&#x3D;&gt; Menus need to be rebuilt
            this.events.next({type: FacetEventType.Loaded});
        });
        // Listen to own events, to trigger change events
        this._events.subscribe(event &#x3D;&gt; {
            if(FACET_CHANGE_EVENTS.indexOf(event.type) !&#x3D;&#x3D; -1){
                this.changes.next(event);
            }
        });
    }

    // GETTERS

    /**
     * Returns the list of this user&#x27;s facets.
     * The list is stored in the user settings (this is a redirection).
     * Using this service creates the list of facets if it does not already exist.
     */
    public get facets() : FacetState[] {
        if(!this.userSettingsService.userSettings)
            this.userSettingsService.userSettings &#x3D; {};
        if(!this.userSettingsService.userSettings[&quot;facets&quot;]) {
            this.userSettingsService.userSettings[&quot;facets&quot;] &#x3D; [];
            if(!!this.defaultFacets){
                this.userSettingsService.userSettings[&quot;facets&quot;].push(...this.defaultFacets);
                this.patchFacets();
            }
        }
        return this.userSettingsService.userSettings[&quot;facets&quot;];
    }

    /**
     * @returns a facet with the given name or undefined if it does not exist
     * @param name
     */
    public facet(name: string): FacetState | undefined {
        const i &#x3D; this.facetIndex(name);
        return i&gt;&#x3D; 0? this.facets[i] : undefined;
    }

    /**
     * Returns the list of facet config in the given container (position)
     * @param position (default to 0 if there is a single container)
     */
    public getFacets(position: number &#x3D; 0) : any[] {
        if (!this.allFacets) {
            return [];
        }
        return this.facets.filter(f &#x3D;&gt; f.position &#x3D;&#x3D;&#x3D; position)
            .map(f &#x3D;&gt; this.allFacets.find(_f &#x3D;&gt; _f.name &#x3D;&#x3D;&#x3D; f.name));
    }

    /**
     * Returns true if this facet is opened (in any container)
     * @param facetName
     */
    public isFacetOpened(facetName): boolean {
        return !!this.facets.find(f &#x3D;&gt; f.name &#x3D;&#x3D;&#x3D; facetName);
    }

    private facetIndex(name: string): number {
        for (let i &#x3D; 0, ic &#x3D; this.facets.length; i &lt; ic; i++) {
            const facet &#x3D; this.facets[i];
            if (facet &amp;&amp; facet.name &#x3D;&#x3D;&#x3D; name) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Triggers any events regarding the facets
     */
    public get events(): Subject&lt;FacetChangeEvent&gt; {
        return this._events;
    }

    /**
     * Triggers when events affect the list of facets
     * Cf. CHANGE_EVENTS list
     */
    public get changes() : Subject&lt;FacetChangeEvent&gt; {
        return this._changes;
    }


    public addFacet(facet: FacetState){
        this.facets.push(facet);
        this.events.next({type : FacetEventType.Add, facet: facet});
        this.patchFacets([{
            type: FacetEventType.Add,
            detail: {
                facet: facet.name
            }
        }]);
    }

    public removeFacet(facet: FacetState){
        const i &#x3D; this.facetIndex(facet.name);
        if(i !&#x3D;&#x3D; -1){
            this.facets.splice(i,1);
            this.events.next({type : FacetEventType.Remove, facet: facet});
            this.patchFacets([{
                type: FacetEventType.Add,
                detail: {
                    facet: facet.name
                }
            }]);
        }
    }


    /**
     * Updates facets in User settings.
     * @param auditEvents : Audit Events to be triggered
     * @returns an Observable which can be used to trigger further events
     */
    private patchFacets(auditEvents?: AuditEvents) {
        return this.userSettingsService.patch({facets: this.facets} as UserSettings, auditEvents)
            .subscribe(
                next &#x3D;&gt; {
                    this.events.next({type: FacetEventType.Patched});
                },
                error &#x3D;&gt; {
                    console.error(&quot;Could not patch Facets!&quot;, error);
            });
    }

    /**
     * Filter/Exclude an item in a facet and launch a search.
     * Triggers an internal event and an Audit Event
     * @param facetName
     * @param aggregation
     * @param items
     * @param options
     */
    public addFilterSearch(
        facetName: string,
        aggregation: Aggregation,
        items: AggregationItem | AggregationItem[],
        options: AddFilterOptions &#x3D; {}): Promise&lt;boolean&gt; {

        this.addFilter(facetName, aggregation, items, options);
        this.events.next({ type: FacetEventType.AddFilter, facet: this.facet(facetName) });
        return this.searchService.search(undefined, {
                type: FacetEventType.AddFilter,
                detail: {
                    item: &lt;any&gt;this.searchService.query.lastSelect(),
                    itembox: facetName,
                    itemcolumn: aggregation.column,
                    isitemexclude: options.not,
                    &quot;from-result-id&quot;: !!this.searchService.results ? this.searchService.results.id : null
                }
            });
    }


    /**
     * Filter/Exclude one or more item(s) in a facet (without launching a search)
     * @param facetName
     * @param aggregation
     * @param items
     * @param options
     */
    public addFilter(
        facetName: string,
        aggregation: Aggregation,
        items: AggregationItem | AggregationItem[],
        options: AddFilterOptions &#x3D; {}) : void {

        if (!items) {
            return;
        }
        if (options.replaceCurrent) {
            this.searchService.query.removeSelect(facetName);
        }
        let _exprs: string[] | undefined;
        let _expr: string &#x3D; &quot;&quot;;
        let addGlobalField &#x3D; !aggregation.valuesAreExpressions;
        if (Utils.isArray(items)) {
            if (items.length &#x3D;&#x3D;&#x3D; 0) {
                return;
            }
            addGlobalField &#x3D; !aggregation.valuesAreExpressions &amp;&amp; items.length &gt; 1;
            const excludeField &#x3D; addGlobalField;
            _exprs &#x3D; items.map(value &#x3D;&gt; FacetService.makeFacetExpr(aggregation, value, excludeField));
            if (_exprs.length &#x3D;&#x3D;&#x3D; 1) {
                _expr &#x3D; _exprs[0];
            }
        }
        else {
            _expr &#x3D; FacetService.makeFacetExpr(aggregation, items as AggregationItem);
        }
        // SINGLE VALUE CASE
        if (_expr) {
            this._addFacetFilter(_expr, facetName, options.not);
            return;
        }
        // AND / OR
        const operator &#x3D; options.and ? &quot; AND &quot; : &quot; OR &quot;;
        let expr &#x3D; &quot;&quot;;
        if (_exprs) {
            for (const _expr of _exprs) {
                if (expr) {
                    expr &#x3D; expr + operator;
                }
                expr +&#x3D; &quot;(&quot; + _expr + &quot;)&quot;;
            }
            expr &#x3D; &quot;(&quot; + expr + &quot;)&quot;;
        }
        if (addGlobalField) {
            expr &#x3D; aggregation.column + &quot;:&quot; + expr;
        }
        this._addFacetFilter(expr, facetName, options.not);
    }

    /**
     * Clears the query from the current selection on the given facet
     * @param facetName
     * @param all
     */
    public clearFilters(facetName: string, all?: boolean) {
        this.searchService.query.removeSelect(facetName, all);
    }

    /**
     * Clears the query from the current selection on the given facet and perform a search
     * @param facetName
     * @param all
     */
    public clearFiltersSearch(facetName: string, all?: boolean): Promise&lt;boolean&gt; {
        this.clearFilters(facetName, all);
        this._events.next({type: FacetEventType.ClearFilters, facet: this.facet(facetName)});
        return this.searchService.search(undefined, {
                type: FacetEventType.ClearFilters,
                detail: {
                    itembox: facetName,
                    &quot;from-result-id&quot;: !!this.searchService.results ? this.searchService.results.id : null
                }
            });
    }

    public removeFilter(facetName: string, aggregation: Aggregation, item: AggregationItem){
        if (this.searchService.breadcrumbs) {
            const expr &#x3D; this.findItemFilter(facetName, aggregation, item);
            const i &#x3D; this.searchService.breadcrumbs.activeSelects.findIndex(select &#x3D;&gt; select.facet &#x3D;&#x3D;&#x3D; facetName &amp;&amp; select.expr &#x3D;&#x3D;&#x3D; expr);
            this.searchService.query.removeSelect(i);
        }
    }

    public removeFilterSearch(facetName: string, aggregation: Aggregation, item: AggregationItem): Promise&lt;boolean&gt;{
        this.removeFilter(facetName, aggregation, item);
        this._events.next({type: FacetEventType.RemoveFilter, facet: this.facet(facetName)});
        return this.searchService.search(undefined); // Note: Audit event generated by the removeBreadcrumbItem call
    }

    private _addFacetFilter(expr: string, facet: string, not?: boolean): number {
        if (not) {
            expr &#x3D; &quot;NOT (&quot; + expr + &quot;)&quot;;
        }
        return this.searchService.query.addSelect(expr, facet);
    }

    /**
     * Queries the server for data for this aggregation
     * @param aggregation
     * @param skip
     * @param count
     */
    public loadData(aggregation: string, skip: number &#x3D; 0, count: number &#x3D; 10): Observable&lt;Aggregation | undefined&gt; {
        const query &#x3D; Utils.copy(this.searchService.query);
        query.action &#x3D; &quot;aggregate&quot;;
        query.aggregations &#x3D; {};
        query.aggregations[aggregation] &#x3D; {skip: skip, count: count};
        return this.searchService.getResults(query, undefined, {searchInactive: true}).pipe(
            map((results: Results) &#x3D;&gt; {
                const data &#x3D; results.aggregations.find(a &#x3D;&gt; Utils.eqNC(a.name, aggregation));
                if (data) {
                    this.setColumn(data);   // Useful for formatting and i18n
                }
                return data;
            })
        );
    }

    /**
     * Get suggestions given a text and a field name, using the Suggest service
     * @param text
     * @param field
     * @param suggestQuery
     */
    public suggest(text: string, field: string, suggestQuery &#x3D; this.appService.suggestQueries[0]): Observable&lt;Suggestion[]&gt; {
        return this.suggestService.get(suggestQuery, text, [field], this.searchService.query);
    }

    /**
     * Format the given result item, using field formatter and/or i18n service
     * @param item
     */
    formatValue(item: AggregationItem): string {
        return this.intlService.formatMessage(
            this.formatService.formatFieldValue(item, item.$column));
    }

    /**
     * Returns true if this facet has at least one active selection
     * filtering the search
     * @param facetName
     */
    public hasFiltered(facetName: string) : boolean {
        return !!this.findFilter(facetName);
    }

    /**
     * Returns an active selection of this facet filtering the search
     * Returns it as an expression
     * @param facetName
     */
    public findFilter(facetName: string) : Expr | undefined {
        if (this.searchService.breadcrumbs) {
            return this.searchService.breadcrumbs.findSelect(facetName);
        }
        return undefined;
    }

    /**
     * Look for an aggregation with the given name in the search results and returns it.
     * Takes care of initializing the aggregation items to insert their $column property.
     * @param aggregationName
     * @param results The search results can be provided explicitly or taken from the SearchService implicitly.
     */
    getAggregation(aggregationName: string, results &#x3D; this.searchService.results): Aggregation | undefined {
        if (results &amp;&amp; results.aggregations) {
            for (const aggregation of results.aggregations) {
                if (Utils.eqNC(aggregation.name, aggregationName)) {
                    this.setColumn(aggregation);    // Useful for formatting and i18n
                    return aggregation;
                }
            }
        }
        return undefined;
    }

    /**
     * Look for a Tree aggregation with the given name in the search results and returns it.
     * Takes care of initializing the Node aggregation items to insert their properties ($column, $path, $opened, $level)
     * @param facetName
     * @param aggregationName
     * @param results The search results can be provided explicitly or taken from the SearchService implicitly.
     * @param levelCallback A callback method called at every level of the tree.
     * Can be used to read or alter the properties of the nodes (opening, closing), or node list (sorting)
     */
    getTreeAggregation(facetName: string, aggregationName: string, results &#x3D; this.searchService.results,
        levelCallback?: (nodes: TreeAggregationNode[], level: number, node?: TreeAggregationNode, opened?: boolean, filtered?: boolean) &#x3D;&gt; void
    ): TreeAggregation | undefined {
        const agg &#x3D; this.getAggregation(aggregationName, results);
        if(agg &amp;&amp; agg.isTree){
            const expr &#x3D; this.findFilter(facetName);
            const expandPaths &#x3D; expr ? expr.getValues(agg.column) : [];
            this.initTreeNodes(facetName, agg, &quot;/&quot;, agg.items as TreeAggregationNode[], expandPaths, levelCallback);

            return agg as TreeAggregation;
        }
        return undefined;
    }

    /**
     * Returns the count parameter of the given aggregation (default is 10)
     * @param aggregationName
     */
    getAggregationCount(aggregationName: string) : number {
        const ccaggregation &#x3D; this.appService.getCCAggregation(aggregationName);
        return (ccaggregation &amp;&amp; ccaggregation.count) || 10;
    }

    /**
     * Opens a Tree node of the given tree facet by querying data from the server
     * Takes care of initializing the Node aggregation items to insert their properties ($column, $path, $opened, $level)
     * @param facetName
     * @param aggregation
     * @param item
     * @param levelCallback A callback method called at every level of the tree.
     * Can be used to read or alter the properties of the nodes (opening, closing), or node list (sorting)
     */
    open(facetName: string, aggregation: TreeAggregation,
        item: TreeAggregationNode,
        levelCallback?: (nodes: TreeAggregationNode[], level: number, node?: TreeAggregationNode, opened?: boolean, filtered?: boolean) &#x3D;&gt; void
    ): Observable&lt;Results&gt; {
        const value &#x3D; item.$path + &quot;*&quot;;
        const query &#x3D; Query.copy(this.searchService.query);
        query.action &#x3D; &quot;open&quot;;
        const expr &#x3D; aggregation.column + &quot;:(&quot; + ExprParser.escape(value) + &quot;)&quot;;
        query.addOpen(expr, aggregation.name);

        this.events.next({type: FacetEventType.Open, facet: this.facet(facetName)});
        return this.searchService.getResults(query, undefined, {searchInactive: true}).pipe(
            map((results: Results) &#x3D;&gt; {
                if (item.$path) {
                    const source &#x3D; FacetService.getAggregationNode(results.aggregations[0].items as TreeAggregationNode[], item.$path);
                    const target &#x3D; FacetService.getAggregationNode(aggregation.items as TreeAggregationNode[], item.$path);
                    if (source &amp;&amp; target) {
                        target.items &#x3D; source.items;    // Insert the new data (source) into the original (target)
                    }
                    if (target &amp;&amp; target.items) {
                        this.initTreeNodes(facetName, aggregation, item.$path, target.items, undefined, levelCallback);
                    }
                }
                return results;
            })
        );
    }

    /**
     * Returns true if a given aggregation item is currently actively filtering the search
     * @param facetName
     * @param aggregation
     * @param item
     */
    itemFiltered(facetName: string, aggregation: Aggregation, item: AggregationItem): boolean {
        return !!this.findItemFilter(facetName, aggregation, item);
    }

    private findItemFilter(facetName: string, aggregation: Aggregation, item: AggregationItem) : Expr | undefined {
        let expr: Expr | undefined;
        if (!aggregation.valuesAreExpressions) {
            let value: string;
            if (aggregation.isTree) {
                value &#x3D; Utils.toSqlValue((&lt;TreeAggregationNode&gt;item).$path + &quot;*&quot;);
            }
            else {
                value &#x3D; Utils.toSqlValue(item.value);
            }
            expr &#x3D; new Expr({
                exprContext: {
                    appService: this.appService,
                    formatService: this.formatService,
                    intlService: this.intlService
                },
                value: value,
                operator: ExprOperator.eq,
                field: aggregation.column
            });
        }
        else {
            const ret &#x3D; this.appService.parseExpr(&lt;string&gt;item.value);
            if (ret instanceof Expr) {
                expr &#x3D; &lt;Expr&gt;ret;
            }
        }
        if (expr) {
            const expr2 &#x3D; this.searchService.breadcrumbs &amp;&amp; this.searchService.breadcrumbs.findSelect(facetName, expr);
            if(!!expr2 &amp;&amp; (!expr2.parent || !expr2.parent.parent)){
                return expr2;
            }
        }
        return undefined;
    }

    /**
     * Initializes the nodes of a tree (private, with a callback)
     * @param facetName
     * @param aggregation
     * @param root
     * @param children
     * @param expandPaths
     * @param levelCallback
     */
    private initTreeNodes(facetName: string, aggregation: Aggregation,
        root: string, children: TreeAggregationNode[],
        expandPaths?: string[],
        levelCallback?: (nodes: TreeAggregationNode[], level: number, node?: TreeAggregationNode, opened?: boolean, selected?: boolean) &#x3D;&gt; void
    ) {
        if (!children) {
            return;
        }
        let rootLevel: number;
        if (root) {
            rootLevel &#x3D; Utils.count(root, &quot;/&quot;, false) - 1;
        }
        else {
            root &#x3D; &quot;/&quot;;
            rootLevel &#x3D; 0;
        }
        const column &#x3D; this.appService.getColumn(aggregation.column);
        FacetService
            .traverse(children, (_nodes) &#x3D;&gt; {
                if (!_nodes) {
                    return false;
                }
                let path &#x3D; root;
                let level &#x3D; rootLevel;
                for (const _node of _nodes) {
                    path &#x3D; path + _node.value + &quot;/&quot;;
                    level++;
                }
                // console.log(path);
                const _node &#x3D; _nodes[_nodes.length - 1];
                _node.$path &#x3D; path;
                _node.$column &#x3D; column;
                _node[&quot;$level&quot;] &#x3D; level;
                _node.$opened &#x3D; false;
                let filtered &#x3D; false;
                if (expandPaths) {
                    for (const expandPath of expandPaths) {
                        if (expandPath.indexOf(path) &#x3D;&#x3D;&#x3D; 0) {
                            if (FacetService.getChildrenCount(_node) &gt; 0) {
                                _node.$opened &#x3D; true;
                            }
                        }
                    }
                }
                if (this.itemFiltered(facetName, aggregation, _node)) {
                    filtered &#x3D; true;
                    _nodes.forEach(node &#x3D;&gt; node.$unselectable &#x3D; true);
                }
                if (levelCallback) {
                    levelCallback(_node.items, level, _node, _node.$opened, filtered);
                }
                return false; // don&#x27;t stop
            });
        if (levelCallback) {
            levelCallback(children, rootLevel);
        }
    }

    private setColumn(aggregation: Aggregation){
        if(!aggregation.isTree &amp;&amp; aggregation.items){
            const column &#x3D; this.appService.getColumn(aggregation.column);
            aggregation.items.forEach((value) &#x3D;&gt; value.$column &#x3D; column);
        }
    }



    // static methods

    /**
     * Create an Expression to filter or exclude an item in a facet
     * @param aggregation the Aggregation to which the item belong
     * @param item the filtered/excluded item (might be a tree item)
     * @param label an optional label to display the value (by default will have none)
     */
    private static makeFacetExpr(
        aggregation: Aggregation,
        item: AggregationItem | TreeAggregationNode,
        excludeField?: boolean,
        label?: string): string {

        let expr: string;
        if (aggregation.valuesAreExpressions) {
            expr &#x3D; &lt;string&gt;item.value;
        }
        else {
            let valueItem: ValueItem &#x3D; item;
            let displayObj: {label?: string, display?: string} | undefined;
            if (label) {
                displayObj &#x3D; {
                    label: label,
                    display: item.display
                };
            }
            if (aggregation.isTree) {
                let display: string;
                if (displayObj) {
                    displayObj.display &#x3D; displayObj.display || &lt;string&gt;item.value;
                    display &#x3D; Utils.toJson(displayObj);
                }
                else {
                    display &#x3D; item.display || &lt;string&gt;item.value;
                }
                valueItem &#x3D; {
                    value: (item as TreeAggregationNode).$path + &quot;*&quot;,
                    display: display
                };
            }
            else {
                if (displayObj) {
                    valueItem &#x3D; {
                        value: item.value,
                        display: Utils.toJson(displayObj)
                    };
                }
            }
            expr &#x3D; this.makeFilterExpr(excludeField? &quot;&quot; : aggregation.column, valueItem);
        }
        if (item.$excluded) {
            expr &#x3D; &quot;NOT (&quot; + expr + &quot;)&quot;;
        }
        return expr;
    }

    // Copied from Search service
    private static makeFilterExpr(field: string, valueItem: ValueItem): string {
        let haveField &#x3D; false;
        const sb: string[] &#x3D; [];
        if (field) {
            sb.push(field);
            haveField &#x3D; true;
        }
        if (valueItem.display) {
            let display &#x3D; valueItem.display;
            if (Utils.isDate(display)) { // ES-7785
                display &#x3D; Utils.toSysDateStr(display);
            }
            sb.push(ExprParser.escape(display));
            haveField &#x3D; true;
        }
        if (haveField) {
            sb.push(&quot;:(&quot;, ExprParser.escape(Utils.toSqlValue(valueItem.value)), &quot;)&quot;);
        }
        else {
            sb.push(ExprParser.escape(Utils.toSqlValue(valueItem.value)));
        }
        return sb.join(&quot;&quot;);
    }

    private static getChildrenCount(node: TreeAggregationNode): number {
        return !!node.items ? node.items.length : node.hasChildren ? -1 : 0;
    }

    private static splitTreepath(path: string): string[] {
        if (!path) return [];
        path &#x3D; path.trim();
        if (path.length &gt; 0 &amp;&amp; path[0] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
            path &#x3D; path.substr(1);
        }
        if (path.length &gt; 0 &amp;&amp; path[path.length - 1] &#x3D;&#x3D;&#x3D; &quot;/&quot;) {
            path &#x3D; path.substr(0, path.length - 1);
        }
        if (path.length &#x3D;&#x3D;&#x3D; 0) {
            return [];
        }
        return path.split(&quot;/&quot;);
    }

    /*private static treepathDepth(path: string): number {
        let names &#x3D; FacetService.splitTreepath(path);
        if (!names) {
            return 0;
        }
        return names.length;
    }*/

    public static treepathLast(path: string): string {
        const parts &#x3D; FacetService.splitTreepath(path);
        if (!parts || parts.length &#x3D;&#x3D;&#x3D; 0) {
            return &quot;&quot;;
        }
        return parts[parts.length - 1];
    }

    /*private static getTreePath(nodes: TreeAggregationNode[], node: TreeAggregationNode) {
        let path: string &#x3D; null;
        FacetService.traverse(nodes, (lineage) &#x3D;&gt; {
            if (lineage) {
                let _node &#x3D; lineage[lineage.length - 1];
                if (node &#x3D;&#x3D;&#x3D; _node) {
                    path &#x3D; &quot;/&quot;;
                    for (let _node of lineage) {
                        path &#x3D; path + _node.value + &quot;/&quot;;
                    }
                    console.log(path);
                    return true; // stop
                }
            }
            return false; // don&#x27;t stop
        });
        return path;
    }*/

    private static traverse(nodes: TreeAggregationNode[], callback: (lineage: TreeAggregationNode[] | undefined) &#x3D;&gt; boolean): boolean {
        if (!nodes || nodes.length &#x3D;&#x3D;&#x3D; 0) {
            return false;
        }
        if (!callback) {
            return false;
        }
        const lineage: TreeAggregationNode[] &#x3D; [];
        const stack: (TreeAggregationNode | undefined)[] &#x3D; [];
        let _i &#x3D; nodes.length;
        while (_i--) {
            stack.push(nodes[_i]);
        }
        while (stack.length) {
            const node &#x3D; stack.pop();
            if (!node) {
                lineage.pop();
                callback(undefined);
            }
            else {
                lineage.push(node);
                if (callback(lineage)) {
                    return true;
                }
                stack.push(undefined);
                if (node.items &amp;&amp; node.items.length &gt; 0) {
                    _i &#x3D; node.items.length;
                    while (_i--) {
                        stack.push(node.items[_i]);
                    }
                }
            }
        }
        return false;
    }

    private static getAggregationNode(nodes: TreeAggregationNode[], path: string): TreeAggregationNode | undefined {
        if (!nodes || nodes.length &#x3D;&#x3D;&#x3D; 0) {
            return undefined;
        }
        const names &#x3D; FacetService.splitTreepath(path);
        let node: TreeAggregationNode | undefined;
        for (let _i &#x3D; 0, _a &#x3D; names; _i &lt; _a.length; _i++) {
            if (!nodes || nodes.length &#x3D;&#x3D;&#x3D; 0) {
                return undefined;
            }
            const name &#x3D; _a[_i].toLocaleLowerCase();
            node &#x3D; undefined;
            for (let _j &#x3D; 0, _b &#x3D; nodes; _j &lt; _b.length; _j++) {
                const _node &#x3D; _b[_j];
                if ((&lt;string&gt;_node.value).toLocaleLowerCase() &#x3D;&#x3D;&#x3D; name) {
                    node &#x3D; _node;
                    break;
                }
            }
            if (!node) {
                return undefined;
            }
            nodes &#x3D; node.items;
        }
        return node;
    }

    /*private static compareFieldValues(a: FieldValue, b: FieldValue): number {
        if (!a &amp;&amp; !b) {
            return 0;
        }
        if (!a) {
            return -1;
        }
        if (!b) {
            return 1;
        }
        if (Utils.isNumber(a) &amp;&amp; Utils.isNumber(b)) {
            return a - b;
        }
        if (Utils.isDate(a) &amp;&amp; Utils.isDate(b)) {
            return a.getTime() - b.getTime();
        }
        if (Utils.isBoolean(a) &amp;&amp; Utils.isBoolean(b)) {
            return (a ? 1 : 0) - (b ? 1 : 0);
        }
        return Utils.compare(String(a), String(b));
    }*/

}</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'FacetState.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
